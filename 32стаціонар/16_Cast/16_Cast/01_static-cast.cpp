#include<iostream>
using namespace std;

void main()
{
	



	//				//dynamic_cast
//	//Используется для динамического приведения типов во время выполнения.
//	//В случае неправильного приведения типов для ссылок вызывается исключительная ситуация std::bad_cast, а для указателей будет возвращен 0. 
//	//Использует систему RTTI(Runtime Type Information).
//	//Безопасное приведение типов по иерархии наследования, в том числе для виртуального наследования.
//	//	return dynamic_cast<C*>(b);// - exept
//	
//				//static_cast 
//	//преобразует выражения одного статического типа в объекты и значения другого статического типа.
//	//Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз.
//	//Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки.
//	//	return static_cast<C*>(b);
//
//				//Си - шный метод приведения типов.Пожалуй самый нежелательный способ приведения типов.Страуструп пишет :
//	//«Например, что это значит выражение — x = (T)y; .Мы не знаем.Это зависит от типа T, типов x и y.T может быть названием типа, 
//	//typedef или может быть параметр template - а.Может быть, х и у являются скалярными переменными и Т представляет собой значение преобразования.
//	//Может быть, х объекта класса, производного от класса Y и Т — нисходящее преобразование.
//	//По этой причине программист может не знать, что он делает на самом деле.»
//	//	Вторая причина нежелательного использования приведения типов в C - style — трудоемкость процесса поиска мест приведения типов.
//	//	return (C*)b;
//				
//				//reinterpret_cast
//	//Приведение типов без проверки. reinterpret_cast — непосредственное указание компилятору.
//	//Применяется только в случае полной уверенности программиста в собственных действиях.
//	//Не снимает константность и volatile.применяется для приведения указателя к указателю, указателя к целому и наоборот.
//	return reinterpret_cast<C*>(b);
//}
}
